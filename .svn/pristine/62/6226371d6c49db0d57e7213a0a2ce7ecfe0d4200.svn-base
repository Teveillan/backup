<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Teveillan]]></title>
  <subtitle><![CDATA[不把CF TC刷红的人生是不完整的。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://teveillan.com/"/>
  <updated>2015-05-07T11:56:08.000Z</updated>
  <id>http://teveillan.com/</id>
  
  <author>
    <name><![CDATA[Teveillan]]></name>
    <email><![CDATA[teveillan@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[编程之美2015初赛第一场]]></title>
    <link href="http://teveillan.com/2015/05/07/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E2015%E5%88%9D%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA/"/>
    <id>http://teveillan.com/2015/05/07/编程之美2015初赛第一场/</id>
    <published>2015-05-07T11:51:01.000Z</published>
    <updated>2015-05-07T11:56:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Hihocoder_1156_彩色的树">Hihocoder 1156 彩色的树</h2><p>题目链接: <a href="http://hihocoder.com/problemset/problem/1156" target="_blank" rel="external">http://hihocoder.com/problemset/problem/1156</a></p>
<p>在每个更新操作的过程中，假设点P最初的颜色为color1，更新后的颜色为color2。<br>我们记与点P相邻，颜色为color1的点为num1, 颜色为color2的点为num2。<br>则 ans -= num1 - 1, ans += num2 + 1。</p>
<p>难点主要在于统计nun1, num2。直接暴力肯定是要TLE的，这里有个技巧。</p>
<p>既然是在树中，我们用map存点P的子节点各种颜色的点有多少个，将父节点单独考虑。<br>查询的过程中:</p>
<ul>
<li><code>num1 = map[P][color1] + (color[ fa[P] ] == color1)</code></li>
<li><code>num2 = map[P][color2] + (color[ fa[p] ] == color2)</code></li>
</ul>
<p>更新的时候只用将父节点的子节点的color1—, color2++。<br>在O(log)级的复杂度内就能完成更新查询操作。<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;head[N];</span><br><span class="line"><span class="keyword">int</span> color[N], fa[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123; <span class="comment">//构建树形结构</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to: head[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(to == fa[cur])   <span class="keyword">continue</span>;</span><br><span class="line">        fa[to] = cur;</span><br><span class="line">        m[cur][<span class="number">0</span>] ++;</span><br><span class="line">        dfs(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> tmp_color, <span class="keyword">int</span> &amp;ans)</span> </span>&#123; <span class="comment">//更新点的同时同时更新ans</span></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    tmp += m[cur][ color[cur] ];</span><br><span class="line">    <span class="keyword">if</span>(color[ fa[cur] ] == color[cur]) ++tmp;</span><br><span class="line">    ans += tmp - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="number">0</span>;</span><br><span class="line">    tmp += m[cur][tmp_color];</span><br><span class="line">    <span class="keyword">if</span>(color[ fa[cur] ] == tmp_color) ++tmp;</span><br><span class="line">    ans -= tmp - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    --m[ fa[cur] ][ color[cur] ];</span><br><span class="line">    ++m[ fa[cur] ][ tmp_color ];</span><br><span class="line">    color[cur] = tmp_color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, casid = <span class="number">0</span>, n, q, x, y, z;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="keyword">sizeof</span>(color));</span><br><span class="line">        FOR(i, <span class="number">1</span>, n)    head[i].clear(), m[i].clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        REP(i, n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            head[x].pb(y);</span><br><span class="line">            head[y].pb(x);</span><br><span class="line">        &#125;</span><br><span class="line">        fa[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ++ casid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        color[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;y, &amp;z);</span><br><span class="line">                update(y, z, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hihocoder_1157_建造金字塔">Hihocoder 1157 建造金字塔</h2><p>题目链接： <a href="http://hihocoder.com/problemset/problem/1157" target="_blank" rel="external">http://hihocoder.com/problemset/problem/1157</a></p>
<p>DP。<br>输入的时候时候一个三角形用顶点坐标<code>(x, y)</code>来表示，我们转化成左右端顶点的横坐标来表示一个三角形<code>(l,r) = (x-y,x+y)</code>。然后按<code>l</code>进行排序。<br>我们用<code>dp[i][j]</code>表示第i个点，且前从前i个三角形选择的三角形中最右端为j的最大获益。<br>假设第i个点的左右端点为<code>(l,r)</code>，利润为v1，成本为v2，分三种情况讨论：</p>
<ol>
<li><code>j &lt;= l：dp[i][r] = max(dp[i][r], dp[i-1][j] + v1 - v2)</code></li>
<li><code>j &gt;= r：dp[i][j] = max(dp[i][j], dp[i-1][j] + v1)</code></li>
<li><code>j &gt; l &amp;&amp; j &lt; r：dp[i][r] = max(dp[i][r], dp[i-1][j] + v1 - v2 + v3)</code>。v3为与之前的重叠面积</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">2</span>][<span class="number">3010</span>]; <span class="comment">//滚动数组，第一维只要2就够了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Trangle &#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">double</span> v1, v2;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Trangle &amp;other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l != other.l)    <span class="keyword">return</span> l &lt; other.l;</span><br><span class="line">        <span class="keyword">return</span> r &lt; other.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, casid = <span class="number">0</span>, n, x, y, z;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Trangle&gt;vec(n);</span><br><span class="line">        REP(i, n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">            vec[i].l = x - y + <span class="number">1000</span>;<span class="comment">//因为x-y有可能小于0,注意不要超出边界 </span></span><br><span class="line">            vec[i].r = x + y + <span class="number">1000</span>;</span><br><span class="line">            vec[i].v1 = z;</span><br><span class="line">            vec[i].v2 = y * y;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(vec.begin(), vec.end()); <span class="comment">//按l排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>, pre = <span class="number">0</span>;</span><br><span class="line">        REP(i, <span class="number">2</span>)</span><br><span class="line">            REP(j, <span class="number">3001</span>)</span><br><span class="line">                dp[i][j] = -<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">        dp[cur][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t: vec) &#123;</span><br><span class="line">            cur ^= <span class="number">1</span>, pre ^= <span class="number">1</span>;</span><br><span class="line">            REP(i, <span class="number">3001</span>)</span><br><span class="line">                dp[cur][i] = -<span class="number">1e18</span>;</span><br><span class="line">            <span class="keyword">int</span> l = t.l, r = t.r;</span><br><span class="line">            REP(i, <span class="number">3001</span>) &#123;<span class="comment">//分三种情况讨论</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt;= r)  dp[cur][i] = max(dp[cur][i], dp[pre][i] + t.v1);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &lt;= l) dp[cur][r] = max(dp[cur][r], dp[pre][i] + t.v1 - t.v2);</span><br><span class="line">                <span class="keyword">else</span> dp[cur][r] = max(dp[cur][r], dp[pre][i] + t.v1 - <span class="built_in">pow</span>((t.r - t.l) / <span class="number">2.0</span>, <span class="number">2.0</span>) + <span class="built_in">pow</span>((i - t.l) / <span class="number">2.0</span>, <span class="number">2.0</span>));</span><br><span class="line"></span><br><span class="line">                dp[cur][i] = max(dp[cur][i], dp[pre][i]);</span><br><span class="line">                ans = max(ans, dp[cur][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %.2lf\n"</span>, ++casid, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hihocoder_1158_质数相关">Hihocoder 1158 质数相关</h2><p>题目链接：<a href="http://hihocoder.com/problemset/problem/1158" target="_blank" rel="external">http://hihocoder.com/problemset/problem/1158</a></p>
<p>二分匹配求最大独立集。<br>可证：<code>如果(a,b)质数相关，(b,c)质数相关，则（a,c）质数无关</code></p>
<p>因此没有奇数环，可划分为二分图。<br>求出二分匹配，最大独立集 = n - 最大匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">bool</span> is_prime[<span class="number">510000</span>], flag[<span class="number">510000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="number">1</span>, <span class="keyword">sizeof</span>(is_prime));</span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line">    FOR(i, <span class="number">2</span>, N) &#123; <span class="comment">//素数筛</span></span><br><span class="line">        <span class="keyword">if</span>(!is_prime[i])    <span class="keyword">continue</span>;</span><br><span class="line">        prime.pb(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= N; j += i)  is_prime[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FOR(i, <span class="number">1</span>, N) <span class="comment">//给每个点染色，因为没有奇数环，所以必然染成或黑或白的一种</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: prime) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; N / x)  <span class="keyword">break</span>;</span><br><span class="line">            flag[i * x] = flag[i] ^ <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Max_Match &#123; <span class="comment">//匈牙利匹配</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;head[<span class="number">1100</span>];</span><br><span class="line">    <span class="keyword">int</span> match_x[<span class="number">1100</span>], match_y[<span class="number">1100</span>];</span><br><span class="line">    <span class="keyword">bool</span> visit[<span class="number">1100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  </span>&#123; head[x].pb(y); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find_path</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> to: head[cur])</span><br><span class="line">            <span class="keyword">if</span>(!visit[to]) &#123;</span><br><span class="line">                visit[to] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(match_y[to] == -<span class="number">1</span> || find_path( match_y[to] )) &#123;</span><br><span class="line">                    match_x[cur] = to;</span><br><span class="line">                    match_y[to] = cur;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;vec)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(match_x, -<span class="number">1</span>, <span class="keyword">sizeof</span>(match_x));</span><br><span class="line">        <span class="built_in">memset</span>(match_y, -<span class="number">1</span>, <span class="keyword">sizeof</span>(match_y));</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        REP(i, n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[ vec[i] ] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">            ret += find_path(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> casnum, casid = <span class="number">0</span>, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum --) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec(n);</span><br><span class="line">        REP(i, n)   <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vec[i]);</span><br><span class="line"></span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        Max_Match match;</span><br><span class="line">        REP(i, n) <span class="comment">//建立二分图</span></span><br><span class="line">            REP(j, i)</span><br><span class="line">                <span class="keyword">if</span>(vec[i] % vec[j] == <span class="number">0</span> &amp;&amp; is_prime[ vec[i] / vec[j] ]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag[ vec[i] ] &lt; flag[ vec[j] ])   match.add(i, j);</span><br><span class="line">                    <span class="keyword">else</span> match.add(j, i);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>, ++casid, n - match.solve(n, vec));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Hihocoder_1156_彩色的树">Hihocoder 1156 彩色的树</h2><p>题目链接: <a href="http://hihocoder.com/problemset/problem/1156">http://hihocoder.com/problemset/problem/1156</a></p>
<p>在每个更新操作的过程中，假设点P最初的颜色为color1，更新后的颜色为color2。<br>我们记与点P相邻，颜色为color1的点为num1, 颜色为color2的点为num2。<br>则 ans -= num1 - 1, ans += num2 + 1。</p>
<p>难点主要在于统计nun1, num2。直接暴力肯定是要TLE的，这里有个技巧。</p>
<p>既然是在树中，我们用map存点P的子节点各种颜色的点有多少个，将父节点单独考虑。<br>查询的过程中:</p>
<ul>
<li><code>num1 = map[P][color1] + (color[ fa[P] ] == color1)</code></li>
<li><code>num2 = map[P][color2] + (color[ fa[p] ] == color2)</code></li>
</ul>
<p>更新的时候只用将父节点的子节点的color1—, color2++。<br>在O(log)级的复杂度内就能完成更新查询操作。<br>]]>
    
    </summary>
    
      <category term="编程之美" scheme="http://teveillan.com/tags/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CDQ分治 && HDU 5126]]></title>
    <link href="http://teveillan.com/2015/05/02/CDQ%E5%88%86%E6%B2%BB/"/>
    <id>http://teveillan.com/2015/05/02/CDQ分治/</id>
    <published>2015-05-02T08:48:26.000Z</published>
    <updated>2015-05-06T13:24:03.000Z</updated>
    <content type="html"><![CDATA[<p>参考文献：<a href="http://wenku.baidu.com/view/52f9c11cff00bed5b9f31d2d.html" target="_blank" rel="external">从《Cash》谈一类分治算法的应用</a> — 陈丹琦</p>
<p>也因此简称CDQ分治。</p>
<p>个人理解CDQ分治和普通分治最大的区别为：<br>普通分治可以将问题拆成几个相互独立的子问题<br>CDQ分治将问题分成了两个部分：</p>
<ol>
<li>相互独立的两个子问题  </li>
<li>两个子问题之间的联系</li>
</ol>
<p>因此，CDQ分治的算法流程也分为以下几步：</p>
<blockquote>
<ol>
<li>算法开始</li>
<li>取一个中间点mid, 将问题分为[L, mid] 和 [mid + 1, R]两个部分。分别处理两个子问题</li>
<li>处理[L, mid] 和 [mid + 1, R]之间的联系</li>
</ol>
</blockquote>
<a id="more"></a>
<p>举个例子：在二维坐标系中，有n个点，m个询问。对于每个询问(x, y)，求点(x1, x2) ，x1&lt;= x &amp;&amp; y1 &lt;= y 有多少个。</p>
<p>当然，这题用树状数组就直接能写了。但是我们在这里用CDQ分治来解决一下这个问题。</p>
<p>我们将n个点看做是n个更新，并和m个询问放在一起。定义一个结构体用vector存起来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sovle1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;Struct&gt;vec1)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在这里将vec1[l, r]按x从小到大排序</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    solve1(l, mid);</span><br><span class="line">    solve1(mid + <span class="number">1</span>, r);<span class="comment">//划分成相互独立的子问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将vec1[l, mid]中的更新操作 和 vec1[mid + 1, r]中的询问操作,存到一个vec2中 </span></span><br><span class="line">    solve2(l, r, vec2);<span class="comment">//左半边的更新操作和右半边的询问操作之间有联系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;Struct&gt;vec2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//此时在solve2中已经不需要管x了。在vec2中所有的更新操作的x必然小于等于询问操作的x。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在这里将vec2[l, r]按y从小到大排序</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    sovle2(l, mid);</span><br><span class="line">    solve2(mid + <span class="number">1</span>, r);<span class="comment">//独立子问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将vec2[l, mid]中的更新操作和vec2[mid + 1, r]中得询问操作存到一个vec3中</span></span><br><span class="line">    solve3(l, r, vec3);<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> solve3（<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;Struct&gt;vec3） &#123;</span><br><span class="line"><span class="comment">//此时在solve3中，x和y都是已经排好序的。从前到后遍历该更新更新该询问询问就好。</span></span><br><span class="line">    <span class="keyword">int</span> cal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(Struct tmp: vec3) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.type == Update)  ++cal;</span><br><span class="line">        <span class="keyword">else</span> tmp.query_anser += cal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这段代码其中有许多可以优化的地方，但是不要在意细节，主要是为了更加方便地理解算法</span></span><br></pre></td></tr></table></figure>
<p>虽然解法不如树状数组，但是我们得看到题目扩展后的好处。<br>我们看到，当到solve2时，函数中的参数<code>vec2</code>已经不用再管他的x了（<code>请务必深刻理解为什么不用再管了</code>）。<br>这样的好处在哪里？没错，<strong>降维！</strong><br>假如我们要处理的不是二维，而是三维四维依旧可以这么处理，每一个维度只不过加了O(log)的复杂度而已。<br><strong>如果是随时可以更新查询的操作，只不过也只是把时间当成一个维度而已。</strong>（光是这一点就已经牛逼哄哄够解决大部分题目了。）</p>
<p>然后就是下面这道题，三维且可随时更新查询：<br>HDU 5126 starts: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5126" target="_blank" rel="external">传送门</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> que[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> z_num;</span><br><span class="line"><span class="keyword">int</span> node[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> Query &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z, kind, id;</span><br><span class="line">    Query() &#123;&#125;</span><br><span class="line">    Query(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y, <span class="keyword">int</span> _z, <span class="keyword">int</span> _kind, <span class="keyword">int</span> _id) : x(_x), y(_y), z(_z), kind(_kind), id(_id) &#123;&#125;</span><br><span class="line">&#125;queries[N &lt;&lt; <span class="number">3</span>], queries_x[N&lt;&lt;<span class="number">3</span>], queries_y[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpx</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x || (a.x == b.x &amp;&amp; a.kind &lt; b.kind);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y || (a.y == b.y &amp;&amp; a.kind &lt; b.kind);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span>    </span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(pos &lt;= z_num) &#123;</span><br><span class="line">        node[pos] += value;</span><br><span class="line">        pos += lowbit(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos) &#123;</span><br><span class="line">        ret += node[pos];</span><br><span class="line">        pos -= lowbit(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve3</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">//只剩下二维y和z，直接就是二维的更新查询题目，树状数组解决就好了</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    FOR(i, l, r)</span><br><span class="line">        <span class="keyword">if</span>(queries_y[i].kind == <span class="number">0</span>)  update(queries_y[i].z, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(queries_y[i].kind == <span class="number">1</span>)  ans[ queries_y[i].id ] -= query(queries_y[i].z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(queries_y[i].kind == <span class="number">2</span>) ans[ queries_y[i].id ] += query(queries_y[i].z);</span><br><span class="line">    FOR(i, l, r)</span><br><span class="line">        <span class="keyword">if</span>(queries_y[i].kind == <span class="number">0</span>)  update(queries_y[i].z, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">//把x这一维度消除</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    solve2(l, mid);</span><br><span class="line">    solve2(mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    FOR(i, l, mid)  <span class="keyword">if</span>(queries_x[i].kind == <span class="number">0</span>)  queries_y[num++] = queries_x[i];</span><br><span class="line">    FOR(i, mid+<span class="number">1</span>, r)    <span class="keyword">if</span>(queries_x[i].kind)  queries_y[num++] = queries_x[i];</span><br><span class="line">    sort(queries_y, queries_y + num, cmpy);</span><br><span class="line">    solve3(<span class="number">0</span>, num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">//已经默认时间从小到大排序了，把时间这一维度消除</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    solve1(l, mid);</span><br><span class="line">    solve1(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    FOR(i, l, mid)  <span class="keyword">if</span>(queries[i].kind == <span class="number">0</span>)    queries_x[num++] = queries[i];</span><br><span class="line">    FOR(i, mid + <span class="number">1</span>, r)  <span class="keyword">if</span>(queries[i].kind)     queries_x[num++] = queries[i];</span><br><span class="line">    sort(queries_x, queries_x + num, cmpx);<span class="comment">//对x从小到大排序</span></span><br><span class="line">    solve2(<span class="number">0</span>, num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, n;</span><br><span class="line">    <span class="keyword">int</span> x1, x2, y1, y2, z1, z2, kind;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, -<span class="number">1</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        z_num = <span class="number">0</span>;</span><br><span class="line">        REP(i, n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;kind);</span><br><span class="line">            <span class="keyword">if</span>(kind == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x1, &amp;y1, &amp;z1);</span><br><span class="line">                queries[id++] = Query(x1, y1, z1, <span class="number">0</span>, i);</span><br><span class="line">                que[z_num++] = z1;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;z1, &amp;x2, &amp;y2, &amp;z2);</span><br><span class="line">                queries[id++] = Query(x2    , y2    , z2    , <span class="number">2</span>, i);</span><br><span class="line">                queries[id++] = Query(x2    , y2    , z1 - <span class="number">1</span>, <span class="number">1</span>, i);</span><br><span class="line">                queries[id++] = Query(x2    , y1 - <span class="number">1</span>, z2    , <span class="number">1</span>, i);</span><br><span class="line">                queries[id++] = Query(x1 - <span class="number">1</span>, y2    , z2    , <span class="number">1</span>, i);</span><br><span class="line">                queries[id++] = Query(x2    , y1 - <span class="number">1</span>, z1 - <span class="number">1</span>, <span class="number">2</span>, i);</span><br><span class="line">                queries[id++] = Query(x1 - <span class="number">1</span>, y2    , z1 - <span class="number">1</span>, <span class="number">2</span>, i);</span><br><span class="line">                queries[id++] = Query(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>, z2    , <span class="number">2</span>, i);</span><br><span class="line">                queries[id++] = Query(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>, z1 - <span class="number">1</span>, <span class="number">1</span>, i);</span><br><span class="line">                que[z_num++] = z2;</span><br><span class="line">                que[z_num++] = z1 - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            sort(que, que + z_num);</span><br><span class="line">            z_num = unique(que, que + z_num) - que;</span><br><span class="line">            REP(i, id)  queries[i].z = lower_bound(que, que + z_num, queries[i].z) - que + <span class="number">1</span>;</span><br><span class="line">            solve1(<span class="number">0</span>, id - <span class="number">1</span>);</span><br><span class="line">            REP(i, n)</span><br><span class="line">                <span class="keyword">if</span>(ans[i] != -<span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>参考文献：<a href="http://wenku.baidu.com/view/52f9c11cff00bed5b9f31d2d.html">从《Cash》谈一类分治算法的应用</a> — 陈丹琦</p>
<p>也因此简称CDQ分治。</p>
<p>个人理解CDQ分治和普通分治最大的区别为：<br>普通分治可以将问题拆成几个相互独立的子问题<br>CDQ分治将问题分成了两个部分：</p>
<ol>
<li>相互独立的两个子问题  </li>
<li>两个子问题之间的联系</li>
</ol>
<p>因此，CDQ分治的算法流程也分为以下几步：</p>
<blockquote>
<ol>
<li>算法开始</li>
<li>取一个中间点mid, 将问题分为[L, mid] 和 [mid + 1, R]两个部分。分别处理两个子问题</li>
<li>处理[L, mid] 和 [mid + 1, R]之间的联系</li>
</ol>
</blockquote>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="Algorithm" scheme="http://teveillan.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5208 Where is Bob && Bestcoder Round38 C题]]></title>
    <link href="http://teveillan.com/2015/04/21/HDU-5208-Where-is-Bob-Bestcoder-Round38-C%E9%A2%98/"/>
    <id>http://teveillan.com/2015/04/21/HDU-5208-Where-is-Bob-Bestcoder-Round38-C题/</id>
    <published>2015-04-21T09:57:45.000Z</published>
    <updated>2015-05-07T11:53:49.000Z</updated>
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5208" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5208</a></p>
<p>近似于数位DP的思路。<br>用数位DP求区间中符号条件的数有多少的时候，有时会用一个符号位来记录当前的取值是否达到区间的上界。这里同样用这个办法。（官方题解我有点没看懂，我的解法有可能和官方题解不一样）</p>
<p>看到题第一眼，觉得应该优先从高位到低位处理，在以下两种情况中，决策应该是确定的：</p>
<ul>
<li>第一个人只能取0或1中的一个。这时候第二个人一定是尽量取和第一个人一样的值。</li>
<li>第二个人只能取0或1中得一个，而第一个人两个都可以选。第一个人自然取第二个人取不到的值。</li>
</ul>
<p>但是，当在这两种情况之外，决策就不唯一了。这时，先把低位的决策解决了就很有必要。<br><a id="more"></a><br>我们用dp[i][l1][r1][l2][r2]来表示。 </p>
<blockquote>
<p><code>l1</code> 为1时，表示 <strong>假设第一个人从最高位到第i+1位的取值都是取区间范围允许的最小值。</strong> 此时，第一个人在第i位的取值要小心不要小于区间允许的最小值。<br>反之<code>l1</code>为0时，表示<strong>假设第一个人从最高位到第i+1位的取值有一个不是区间范围的最小值</strong>，这时候，从第i位到第0位取任何值都不会小于区间允许的最小值了。</p>
</blockquote>
<p>请仔细理解上面这段话。</p>
<p>同理，<code>r1</code>代表之前取的是不是区间范围允许的最大值。然后能类推倒l2, r2。</p>
<p>对于每一位, 我们枚举l1, r1, l2, r2。<strong>（再次阐明一下，l1, r1, l2, r2不是表示第i位两个人的取值范围，是表示高位的取值是不是都是边界值。）</strong> 当l1, r1, l2, r2确定以后，第i位两个人的取值范围也就确定了，枚举两个人的取值，用第i-1位递推到第i位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;pii;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">40</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, casid = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        REP(i, <span class="number">31</span>)</span><br><span class="line">            REP(a, <span class="number">2</span>)</span><br><span class="line">                REP(b, <span class="number">2</span>)</span><br><span class="line">                    REP(c, <span class="number">2</span>)</span><br><span class="line">                        REP(d, <span class="number">2</span>)</span><br><span class="line">                            dp[i][a][b][c][d] = <span class="number">1e15</span>;</span><br><span class="line">        <span class="keyword">int</span> l[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        REP(i, <span class="number">2</span>)</span><br><span class="line">            REP(j, <span class="number">2</span>)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; l[i][j];</span><br><span class="line"></span><br><span class="line">        FOR(i, <span class="number">0</span>, <span class="number">31</span>) &#123;</span><br><span class="line">            REP(a, <span class="number">2</span>)</span><br><span class="line">                REP(b, <span class="number">2</span>)</span><br><span class="line">                    REP(c, <span class="number">2</span>)</span><br><span class="line">                        REP(d, <span class="number">2</span>) &#123; <span class="comment">//枚举高位的取值是不是都是边界值</span></span><br><span class="line">                            <span class="keyword">bool</span> tmp_l[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125; &#125;; </span><br><span class="line">                            <span class="comment">// 确定此时两个人的取值范围</span></span><br><span class="line">                            <span class="keyword">if</span>(a)   tmp_l[<span class="number">0</span>][<span class="number">0</span>] = l[<span class="number">0</span>][<span class="number">0</span>] &amp; (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                            <span class="comment">//当第一个人高位的取值都是下界值，而且第i位的下界值为1时</span></span><br><span class="line">                            <span class="comment">//第i位的取值范围的下界为1。否则第i位的取值范围的下界为0。</span></span><br><span class="line">                            <span class="keyword">if</span>(b)   tmp_l[<span class="number">0</span>][<span class="number">1</span>] = l[<span class="number">0</span>][<span class="number">1</span>] &amp; (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                            <span class="comment">//都类比第一个</span></span><br><span class="line">                            <span class="keyword">if</span>(c)   tmp_l[<span class="number">1</span>][<span class="number">0</span>] = l[<span class="number">1</span>][<span class="number">0</span>] &amp; (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                            <span class="keyword">if</span>(d)   tmp_l[<span class="number">1</span>][<span class="number">1</span>] = l[<span class="number">1</span>][<span class="number">1</span>] &amp; (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line"></span><br><span class="line">                            ll tmp1 = <span class="number">0</span>;</span><br><span class="line">                            FOR(j, tmp_l[<span class="number">0</span>][<span class="number">0</span>], tmp_l[<span class="number">0</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                            <span class="comment">//取值范围确定了，现在我们来枚举值。j是第一个人的取值</span></span><br><span class="line">                                ll tmp2 = <span class="number">1e15</span>;</span><br><span class="line">                                FOR(k, tmp_l[<span class="number">1</span>][<span class="number">0</span>], tmp_l[<span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                                    <span class="comment">//第i位的异或值加上i-1位的dp值就是第i位的dp值。</span></span><br><span class="line">                                    <span class="comment">//但是我们得先算出两个人分别取j和k的情况下</span></span><br><span class="line">                                    <span class="comment">//高位的取值加上第i位的取值是否依然达到上下界</span></span><br><span class="line">                                    <span class="keyword">bool</span> tmp[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125; &#125;;</span><br><span class="line">                                    <span class="keyword">if</span>(a &amp;&amp; (j == tmp_l[<span class="number">0</span>][<span class="number">0</span>])) tmp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                                    <span class="comment">//当且仅当高位取值到达下界,第i位又取到下界值得时候,</span></span><br><span class="line">                                    <span class="comment">//对i-1位来说高位的取值达到下界</span></span><br><span class="line">                                    <span class="keyword">if</span>(b &amp;&amp; (j == tmp_l[<span class="number">0</span>][<span class="number">1</span>])) tmp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">if</span>(c &amp;&amp; (k == tmp_l[<span class="number">1</span>][<span class="number">0</span>])) tmp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">if</span>(d &amp;&amp; (k == tmp_l[<span class="number">1</span>][<span class="number">1</span>])) tmp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">if</span>(i)</span><br><span class="line">                                        tmp2 = min(tmp2, ((ll)(j^k) &lt;&lt; i) + dp[i-<span class="number">1</span>][tmp[<span class="number">0</span>][<span class="number">0</span>]][tmp[<span class="number">0</span>][<span class="number">1</span>]][tmp[<span class="number">1</span>][<span class="number">0</span>]][tmp[<span class="number">1</span>][<span class="number">1</span>]]);</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        tmp2 = min(tmp2, ((ll)(j^k) &lt;&lt; i));</span><br><span class="line">                                &#125;</span><br><span class="line">                                tmp1 = max(tmp1, tmp2);</span><br><span class="line">                            &#125;</span><br><span class="line">                            dp[i][a][b][c][d] = tmp1;</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = dp[<span class="number">31</span>][<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %I64d\n"</span>, ++casid, ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5208">http://acm.hdu.edu.cn/showproblem.php?pid=5208</a></p>
<p>近似于数位DP的思路。<br>用数位DP求区间中符号条件的数有多少的时候，有时会用一个符号位来记录当前的取值是否达到区间的上界。这里同样用这个办法。（官方题解我有点没看懂，我的解法有可能和官方题解不一样）</p>
<p>看到题第一眼，觉得应该优先从高位到低位处理，在以下两种情况中，决策应该是确定的：</p>
<ul>
<li>第一个人只能取0或1中的一个。这时候第二个人一定是尽量取和第一个人一样的值。</li>
<li>第二个人只能取0或1中得一个，而第一个人两个都可以选。第一个人自然取第二个人取不到的值。</li>
</ul>
<p>但是，当在这两种情况之外，决策就不唯一了。这时，先把低位的决策解决了就很有必要。<br>]]>
    
    </summary>
    
      <category term="BestCoder" scheme="http://teveillan.com/tags/BestCoder/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[BestCoder Round #25]]></title>
    <link href="http://teveillan.com/2015/01/09/BestCoder-Round-25/"/>
    <id>http://teveillan.com/2015/01/09/BestCoder-Round-25/</id>
    <published>2015-01-09T05:57:46.000Z</published>
    <updated>2015-05-07T11:53:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1001_Harry_and_Magical_Computer">1001 Harry and Magical Computer</h2><p>就是判断有没有环存在。<br>点比较少，Floyd一遍O(n^3)就行。</p>
<h2 id="1002_Harry_And_Magic_Box">1002 Harry And Magic Box</h2><p>官方题解是O(n^4)的，其实中间有一维可以省略。（小地方而已。。不管也罢。。）<br><a id="more"></a><br>dp[i][j]表示第i行已经有j列被选过（这j个不一定全都是在第i行选的，有可能包括之前选的）。<br>则dp公式为： <code>(1 &lt;= k &lt;= j)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(k == j)</span><br><span class="line">    dp[i][j] += dp[i-<span class="number">1</span>][k] * ((<span class="number">1</span>&lt;&lt;k) - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dp[i][j] += dp[i-<span class="number">1</span>][k] * (<span class="number">1</span>&lt;&lt;k) * c[m-k][j-k];</span><br></pre></td></tr></table></figure>
<p>表示假如<code>k==j</code>，前k个中至少选一个，种类数为<code>((1&lt;&lt;k) - 1)</code>。<br>否则， 前k个随便选， 其余从<code>m-k</code>中选<code>j-k</code>个。<br>注意数据溢出。</p>
<h2 id="1003_Harry_and_Christmas_tree">1003 Harry and Christmas tree</h2><p>我是按照官方题解的思路。<br>对每种颜色单独考虑。对第i-1个有这种颜色点a, 第i个有这种颜色的点b， 以及a和b的lca点c。 在递归过程中，c之前的点都可以被贡献1中颜色，直到c以及c往上，贡献度为a和b各一个，然后减去a和b的重复一个，总共为1。</p>
<p>中间要用到lca算法，因为这道题就是按照递归的顺序进行遍历，用离线的lca就行。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;head[N], gift[N];</span><br><span class="line"><span class="keyword">int</span> fa[N], ans[N];</span><br><span class="line"><span class="keyword">int</span> pre_color[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])    <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    REP(i, head[now].size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head[now][i] != pre) &#123;</span><br><span class="line">            dfs(head[now][i], now); </span><br><span class="line">            fa[ head[now][i] ] = now; <span class="comment">//离线lca中得一部分</span></span><br><span class="line">            ans[now] += ans[ head[now][i] ]; <span class="comment">//将子节点的贡献度加上来。（这时候子节点的贡献度已经是 总贡献度 - 重复次数 了）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    REP(i, gift[now].size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> color = gift[now][i];</span><br><span class="line">        <span class="keyword">if</span>(!pre_color[color])  &#123; <span class="comment">//第一个出现这种颜色，跳过不处理</span></span><br><span class="line">            pre_color[color] = now;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lca = find(pre_color[color]); <span class="comment">// 找lca</span></span><br><span class="line">        --ans[lca]; <span class="comment">// 在lca上加上一个重复度, ans--</span></span><br><span class="line"></span><br><span class="line">        pre_color[color] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[now] += gift[now].size(); <span class="comment">//加上本节点的贡献</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(pre_color, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre_color));</span><br><span class="line">        FOR(i, <span class="number">1</span>, n)    fa[i] = i, head[i].clear(), gift[i].clear();</span><br><span class="line">        REP(i, n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x, &amp;y);</span><br><span class="line">            head[x].pb(y);</span><br><span class="line">            head[y].pb(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            gift[x].pb(y);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        FOR(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span>)    <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Harry_and_magic_string">Harry and magic string</h2><p>DP + Manacher算法</p>
<p>DP思路很简单。<br>sum[i] 表示以i结尾和i之前结尾的回文串总数。<br>dp[i] 表示以i开头的回文串数。</p>
<blockquote>
<p>ans = $$\sum_{i=1}^{len-1} {sum[i-1] * dp[i]}$$</p>
</blockquote>
<p>难点就是<code>sum[i]</code> 和 <code>dp[i]</code> 怎么求的问题了。<br>新学习了个算法， Manacher算法，在我转载的上篇文章中有讲解。<a href="http://teveillan.com/2015/01/09/-%E8%BD%AC-Manacher%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%96%87%E4%B8%B2%E5%A4%84%E7%90%86/" target="_blank" rel="external">传送门</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[MAX_LEN];</span><br><span class="line"><span class="keyword">int</span> Len[MAX_LEN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> Manacher &#123; <span class="comment">// Manacher算法, 讲解看上篇文章</span></span><br><span class="line">    <span class="keyword">char</span> tmp_str[MAX_LEN&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        tmp_str[id++] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">            tmp_str[id++] = s[i];</span><br><span class="line">            tmp_str[id++] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_str[id] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = init(s);</span><br><span class="line">        <span class="keyword">int</span> max_r = -<span class="number">1</span>, max_id = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(max_r &gt; i)   Len[i] = min(max_r - i, Len[<span class="number">2</span> * max_id - i]);</span><br><span class="line">            <span class="keyword">else</span> Len[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i - Len[i] &gt;= <span class="number">0</span> &amp;&amp; i + Len[i] &lt; len &amp;&amp; tmp_str[i - Len[i]] == tmp_str[i + Len[i]])</span><br><span class="line">                ++Len[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i + Len[i] &gt; max_r) &#123;</span><br><span class="line">                max_r = i + Len[i];</span><br><span class="line">                max_id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[MAX_LEN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> flag[MAX_LEN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="number">0</span> ,<span class="keyword">sizeof</span>(flag));</span><br><span class="line">        Manacher manacher;</span><br><span class="line">        manacher.solve(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (len&lt;&lt;<span class="number">1</span>); ++i) &#123; <span class="comment">//求sum</span></span><br><span class="line">            sum[i] += sum[i-<span class="number">1</span>];</span><br><span class="line">            ++tmp;</span><br><span class="line"></span><br><span class="line">            tmp -= flag[i];</span><br><span class="line">            ++flag[i + Len[i]];</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) sum[i] += tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">        tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (len&lt;&lt;<span class="number">1</span>); i &gt;= <span class="number">1</span>; --i) &#123; <span class="comment">//求ans</span></span><br><span class="line">            ++tmp;</span><br><span class="line">            tmp -= flag[i];</span><br><span class="line">            ++flag[i - Len[i]];</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) ans += sum[i-<span class="number">1</span>] * tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1001_Harry_and_Magical_Computer">1001 Harry and Magical Computer</h2><p>就是判断有没有环存在。<br>点比较少，Floyd一遍O(n^3)就行。</p>
<h2 id="1002_Harry_And_Magic_Box">1002 Harry And Magic Box</h2><p>官方题解是O(n^4)的，其实中间有一维可以省略。（小地方而已。。不管也罢。。）<br>]]>
    
    </summary>
    
      <category term="BestCoder" scheme="http://teveillan.com/tags/BestCoder/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转] Manacher算法-回文串处理]]></title>
    <link href="http://teveillan.com/2015/01/09/-%E8%BD%AC-Manacher%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%96%87%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <id>http://teveillan.com/2015/01/09/-转-Manacher算法-回文串处理/</id>
    <published>2015-01-09T03:45:39.000Z</published>
    <updated>2015-05-06T13:24:03.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Manacher</strong>算法是查找一个字符串的最长回文子串的线性算法。<br>在介绍算法之前，首先介绍一下什么是回文串，所谓回文串，简单来说就是正着读和反着读都是一样的字符串，比如abba，noon等等，一个字符串的最长回文子串即为这个字符串的子串中，是回文串的最长的那个。<br>计算字符串的最长回文字串最简单的算法就是枚举该字符串的每一个子串，并且判断这个子串是否为回文串，这个算法的时间复杂度为O(n^3)的，显然无法令人满意，稍微优化的一个算法是枚举回文串的中点，这里要分为两种情况，一种是回文串长度是奇数的情况，另一种是回文串长度是偶数的情况，枚举中点再判断是否是回文串，这样能把算法的时间复杂度降为O(n^2)，但是当n比较大的时候仍然无法令人满意，Manacher算法可以在线性时间复杂度内求出一个字符串的最长回文字串，达到了理论上的下界。</p>
<a id="more"></a>
<h1 id="Manacher算法原理与实现">Manacher算法原理与实现</h1><p>下面介绍Manacher算法的原理与步骤。<br>首先，Manacher算法提供了一种巧妙地办法，将长度为奇数的回文串和长度为偶数的回文串一起考虑，具体做法是，在原字符串的每个相邻两个字符中间插入一个分隔符，同时在首尾也要添加一个分隔符，分隔符的要求是不在原串中出现，一般情况下可以用#号。下面举一个例子：<br><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-1.png" alt=""></p>
<h2 id="Len数组简介与性质">Len数组简介与性质</h2><p>Manacher算法用一个辅助数组Len[i]表示以字符T[i]为中心的最长回文字串的最右字符到T[i]的长度，比如以T[i]为中心的最长回文字串是T[l,r],那么Len[i]=r-i+1。<br>对于上面的例子，可以得出Len[i]数组为:</p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-2.png" alt=""></p>
<p>Len数组有一个性质，那就是Len[i]-1就是该回文子串在原字符串S中的长度，至于证明，首先在转换得到的字符串T中，所有的回文字串的长度都为奇数，那么对于以T[i]为中心的最长回文字串，其长度就为2*Len[i]-1,经过观察可知，T中所有的回文子串，其中分隔符的数量一定比其他字符的数量多1，也就是有Len[i]个分隔符，剩下Len[i]-1个字符来自原字符串，所以该回文串在原字符串中的长度就为Len[i]-1。<br>有了这个性质，那么原问题就转化为求所有的Len[i]。下面介绍如何在线性时间复杂度内求出所有的Len。</p>
<h2 id="Len数组的计算">Len数组的计算</h2><p>首先从左往右依次计算Len[i]，当计算Len[i]时，Len<a href="0&lt;=j&lt;i">j</a>已经计算完毕。设P为之前计算中最长回文子串的右端点的最大值，并且设取得这个最大值的位置为po，分两种情况：<br>第一种情况：i&lt;=P<br>那么找到i相对于po的对称位置，设为j，那么如果Len[j]&lt;P-i，如下图：</p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-3.png" alt=""></p>
<p>那么说明以j为中心的回文串一定在以po为中心的回文串的内部，且j和i关于位置po对称，由回文串的定义可知，一个回文串反过来还是一个回文串，所以以i为中心的回文串的长度至少和以j为中心的回文串一样，即Len[i]&gt;=Len[j]。因为Len[j]<p-i,所以说i+len[j]<p。由对称性可知len[i]=len[j]。 如果len[j]="">=P-i,由对称性，说明以i为中心的回文串可能会延伸到P之外，而大于P的部分我们还没有进行匹配，所以要从P+1位置开始一个一个进行匹配，直到发生失配，从而更新P和对应的po以及Len[i]。</p-i,所以说i+len[j]<p。由对称性可知len[i]=len[j]。></p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-4.png" alt=""></p>
<p>第二种情况: i&gt;P<br>如果i比P还要大，说明对于中点为i的回文串还一点都没有匹配，这个时候，就只能老老实实地一个一个匹配了，匹配完成后要更新P的位置和对应的po以及Len[i]。</p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-5.png" alt=""></p>
<h1 id="时间复杂度分析">时间复杂度分析</h1><p>Manacher算法的时间复杂度分析和Z算法类似，因为算法只有遇到还没有匹配的位置时才进行匹配，已经匹配过的位置不再进行匹配，所以对于T字符串中的每一个位置，只进行一次匹配，所以Manacher算法的总体时间复杂度为O(n)，其中n为T字符串的长度，由于T的长度事实上是S的两倍，所以时间复杂度依然是线性的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Len[MAX_LEN&lt;&lt;<span class="number">1</span>]; <span class="comment">//记录算法完成后以i点为中心最长回文串向左向右延伸的半径</span></span><br><span class="line"><span class="keyword">struct</span> Manacher &#123;</span><br><span class="line">    <span class="keyword">char</span> tmp_str[MAX_LEN&lt;&lt;<span class="number">1</span>]; <span class="comment">//记录预处理过后的字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123; <span class="comment">//在solve中就直接调用了。对原串进行预处理。</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        tmp_str[id++] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">            tmp_str[id++] = s[i];</span><br><span class="line">            tmp_str[id++] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_str[id] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> id; <span class="comment">//此时的id即为处理过后的字符串长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123; <span class="comment">//从这开始处理</span></span><br><span class="line">        <span class="keyword">int</span> len = init(s);</span><br><span class="line">        <span class="keyword">int</span> max_r = -<span class="number">1</span>, max_id = -<span class="number">1</span>; <span class="comment">// 最右能到得地方，以及最右时的中心点id</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(max_r &gt; i)   Len[i] = min(max_r - i, Len[<span class="number">2</span> * max_id - i]);</span><br><span class="line">            <span class="keyword">else</span> Len[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i - Len[i] &gt;= <span class="number">0</span> &amp;&amp; i + Len[i] &lt; len &amp;&amp; tmp_str[i - Len[i]] == tmp_str[i + Len[i]])</span><br><span class="line">                ++Len[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i + Len[i] &gt; max_r) &#123;</span><br><span class="line">                max_r = i + Len[i];</span><br><span class="line">                max_id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>转自：<a href="http://blog.csdn.net/dyx404514/article/details/42061017" target="_blank" rel="external">http://blog.csdn.net/dyx404514/article/details/42061017</a><br>作者：dyx心心</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Manacher</strong>算法是查找一个字符串的最长回文子串的线性算法。<br>在介绍算法之前，首先介绍一下什么是回文串，所谓回文串，简单来说就是正着读和反着读都是一样的字符串，比如abba，noon等等，一个字符串的最长回文子串即为这个字符串的子串中，是回文串的最长的那个。<br>计算字符串的最长回文字串最简单的算法就是枚举该字符串的每一个子串，并且判断这个子串是否为回文串，这个算法的时间复杂度为O(n^3)的，显然无法令人满意，稍微优化的一个算法是枚举回文串的中点，这里要分为两种情况，一种是回文串长度是奇数的情况，另一种是回文串长度是偶数的情况，枚举中点再判断是否是回文串，这样能把算法的时间复杂度降为O(n^2)，但是当n比较大的时候仍然无法令人满意，Manacher算法可以在线性时间复杂度内求出一个字符串的最长回文字串，达到了理论上的下界。</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://teveillan.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(转) Mac中安装Vim7.4]]></title>
    <link href="http://teveillan.com/2015/01/07/Mac%E4%B8%AD%E5%AE%89%E8%A3%85Vim7-4/"/>
    <id>http://teveillan.com/2015/01/07/Mac中安装Vim7-4/</id>
    <published>2015-01-07T04:58:51.000Z</published>
    <updated>2015-05-06T13:24:03.000Z</updated>
    <content type="html"><![CDATA[<p>Mac本身其实是预装了Vim的，但是目前的系统中都是Vim7.3版本的，而最新的Vim已经是7.4版了，因此为了能够使用最新版的vim，必须要对Mac中的vim要么升级，要么重装。在折腾过程中，遇到了一些问题，这里记录，以鉴后人。</p>
<a id="more"></a>
<h1 id="可选方案"><strong>可选方案</strong></h1><p><strong>升级原生的Vim7.3</strong><br> 这种方法貌似是最”干净”的，不会引入其他任何多余的东西，对于有洁癖的人这应该是一种比较好的方案。但是，这个方案也有缺点，那就是它会覆盖原生的Vim，会改变系统的默认设置，并且一旦升级过程中出现了问题，那你就再也没有可用的vim了。另外一个问题是，以后当你系统升级的时候，很有可能你自己的vim又会被新系统的vim给覆盖，这样会比较麻烦。</p>
<p><strong>使用MacVim</strong><br>这是一种比较好的方案，Vim官网上也是推荐使用这种方案的，MacVim是针对Mac系统特别定制的Vim版本，安装过程也很简单，网上一搜一大把。它功能上和vim完全一致，不会有任何的问题。要说这种方案其实已经算是一个完美的解决方案了，但是它有一点不太方便的地方，那就是不能直接在终端中使用vim，每次使用MacVim的时候都会单独开启一个窗口，有点类似于windows中的gvim。而我个人是比较习惯在终端中写代码的，因此这个方案还是不能满足我的需求。</p>
<p><strong>自己编译</strong><br>这是一种终极的方案，但是自己编译的时候注意要手动更改默认的安装目录，不然它就会覆盖原生的vim7.3，这样就会变成第一种方案了。将vim7.4安装在其他目录，然后在.bash_profile中添加一个vim命令的别名，将其指向新安装的vim7.4的目录，而不是原生的vim7.3目录。这个方案就能在终端中直接使用vim7.4了，并且不会对原生的vim7.3又任何影响。这个方案唯一的缺点大概就是会在系统中产生两个不同版本的vim了，这也许对一些有洁癖的人是难以接受的。</p>
<p>我自己最终选择了第三套方案，也就是自己编译新版本的vim.</p>
<h1 id="重新编译"><strong>重新编译</strong></h1><p>好了，现在让我们开始折腾吧。</p>
<p>首先上vim的官网下载vim7.4的源文件。（<a href="http://www.vim.org/sources.ph" target="_blank" rel="external">下载链接</a>）</p>
<p>新建目录<code>/opt/local</code>，这个目录就是用来存放我们新安装的vim7.4的，你也可以建立其他的目录，这里只是一个示例。</p>
<p>进入vim的源文件目录中，在终端中运行命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-features=huge --enable-pythoninterp=yes  --enable-cscope --enable-fontset --enable-perlinterp --enable-rubyinterp --with-python-config-dir=/usr/lib/python2.<span class="number">6</span>/config --prefix=/opt/<span class="built_in">local</span></span><br></pre></td></tr></table></figure></p>
<p>这个命令是完成对vim的一些配置选项，启用了python和ruby的支持特性，这还是比较重要的，因为vim中有些插件会使用python和ruby的，如果没有开启这些特性，有些插件是无法运行的。在这些配置命令中，最后一个<code>--prefix=/opt/local</code>是用来指明安装目录的，你也可以修改成你自己的目录。</p>
<p>在写配置命令的时候，需要注意的是，不能写上<code>--enable-gui</code>，这是开启gui特性的，但是我们是在终端环境下安装的，因此不能开启这个特性，否则会出现编译错误。</p>
<p>在终端中执行<code>make</code>命令。在make过程中，会出现一个错误，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:info:build os_unix.c:<span class="number">830</span>:<span class="number">46</span>: warning: declaration of <span class="string">'struct sigaltstack'</span> will not be visible outside of this <span class="keyword">function</span> [-Wvisibility]</span><br><span class="line">:info:build         extern int sigaltstack __ARGS((const struct sigaltstack *ss, struct sigaltstack *oss));</span><br><span class="line">:info:build                                                     ^</span><br><span class="line">:info:build ./os_unix.h:<span class="number">88</span>:<span class="number">21</span>: note: expanded from macro <span class="string">'__ARGS'</span></span><br><span class="line">:info:build <span class="comment">#  define __ARGS(x) x</span></span><br><span class="line">:info:build                     ^</span><br><span class="line">:info:build os_unix.c:<span class="number">830</span>:<span class="number">13</span>: error: conflicting types <span class="keyword">for</span> <span class="string">'sigaltstack'</span></span><br><span class="line">:info:build         extern int sigaltstack __ARGS((const struct sigaltstack *ss, struct sigaltstack *oss));</span><br><span class="line">:info:build                    ^</span><br><span class="line">:info:build /usr/include/signal.h:<span class="number">89</span>:<span class="number">5</span>: note: previous declaration is here</span><br><span class="line">:info:build int     sigaltstack(const stack_t * __restrict, stack_t * __restrict)  __DARWIN_ALIAS(sigaltstack);</span><br><span class="line">:info:build         ^</span><br><span class="line">:info:build <span class="number">1</span> warning and <span class="number">1</span> error generated.</span><br><span class="line">:info:build make[<span class="number">1</span>]: *** [objects/os_unix.o] Error <span class="number">1</span></span><br><span class="line">:info:build make[<span class="number">1</span>]: *** Waiting <span class="keyword">for</span> unfinished <span class="built_in">jobs</span>….)</span><br></pre></td></tr></table></figure></p>
<p>解决方案也很简单，只需要在os_unix.h(src文件夹中)中加上<code>#include &lt;AvailabilityMacros.h&gt;</code>就可以了。</p>
<p>执行<code>make install</code>.执行完成之后，vim7.4就安装完成了。</p>
<p>添加vim命令的别名，在.bash_profile中添加一行<code>alias vim=&#39;/opt/local/bin/vim&#39;</code>，然后在终端中执行<code>source ~/.bash_profile</code></p>
<p>好了，现在你的Mac系统已经安装好了vim7.4了，现在可以开始愉快的工作了。</p>
<p>参考资料<br><a href="http://stackoverflow.com/questions/7211820/update-built-in-vim-on-mac-os-x" target="_blank" rel="external">http://stackoverflow.com/questions/7211820/update-built-in-vim-on-mac-os-x</a><br><a href="http://www.jokerlin.us/2014/04/13/Vim74.html" target="_blank" rel="external">http://www.jokerlin.us/2014/04/13/Vim74.html</a><br><a href="http://trac.macports.org/ticket/41774" target="_blank" rel="external">http://trac.macports.org/ticket/41774</a></p>
<p>声明:本文采用<code>BY-NC-SA</code>协议进行授权.转载请注明: <a href="http://zhouyichu.com/vim/Vim-in-Mac.html" target="_blank" rel="external">Mac中安装Vim7.4</a><br>转自:Flyaway<br>原文链接: <a href="http://zhouyichu.com/vim/Vim-in-Mac.html" target="_blank" rel="external">http://zhouyichu.com/vim/Vim-in-Mac.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Mac本身其实是预装了Vim的，但是目前的系统中都是Vim7.3版本的，而最新的Vim已经是7.4版了，因此为了能够使用最新版的vim，必须要对Mac中的vim要么升级，要么重装。在折腾过程中，遇到了一些问题，这里记录，以鉴后人。</p>]]>
    
    </summary>
    
      <category term="MacOS" scheme="http://teveillan.com/tags/MacOS/"/>
    
      <category term="VIM" scheme="http://teveillan.com/tags/VIM/"/>
    
      <category term="Tech" scheme="http://teveillan.com/categories/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最短路 SPFA]]></title>
    <link href="http://teveillan.com/2015/01/04/%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA/"/>
    <id>http://teveillan.com/2015/01/04/最短路-SPFA/</id>
    <published>2015-01-04T07:32:34.000Z</published>
    <updated>2015-05-07T08:05:28.000Z</updated>
    <content type="html"><![CDATA[<p>首先，为了简化分析，我们假定图中是没有负环的。<br>如果有负环，则就没有最短路径。</p>
<blockquote>
<p>负环：一条从a到a的路径，路径上每条边的边权和为负。</p>
</blockquote>
<p>但是SPFA算法是可以判断是否有负环存在的，比较基本的做法是判断每个点进队出队的次数，这个复杂度比较高。其实有一种DFS版的SPFA，用这个来判断是否有负环的效率是非常高的，这个我们后续再讲。</p>
<p>最短路的算法中都用着一种通用的思路：</p>
<ul>
<li>初始化</li>
<li>松弛操作<a id="more"></a>
初始化自然不用说。<br>最开始还没有进行任何操作，每个点（除了起始点）距离起始点的距离为无穷大（记为dis[i]=INF），起始点到起始点的距离为0（记作dis[start]=0）。</li>
</ul>
<p>然后是松弛操作，也是本篇文章的主要部分。<br>松弛操作的要达到的目的是：</p>
<ul>
<li><strong> 对于任意点u, 将从起始点到u的最短距离记为dis[u]。 </strong></li>
<li><strong> 对于点u的任意相邻点v, 满足dis[v] &lt;= dis[u] + d[u,v] </strong></li>
</ul>
<blockquote>
<p>u与v相邻：存在一条边 u-&gt;v</p>
</blockquote>
<p>为什么要满足这样一个条件呢？</p>
<p>拿v点举例。<br>我们知道，一条从起始点s到v点的最短路径不可能是凭空产生的，从起始点到v点的最短路径在两种情况下可能产生：</p>
<ul>
<li><strong> s与v相邻，(s,v)这条边就可能（但不是一定）就直接是一条最短路径。</strong></li>
<li><strong> 有一个点u与v相邻，通过s到u的的最短路径，延伸出一条从s到v得最短路径。 </strong></li>
</ul>
<p>对于第一种情况，很明显一次就直接能找到最短路径。</p>
<p>对于第二种情况，假设到点v的最终最短路径是先从s到u, 再从u到v。<br>在算法执行的过程中，我们不知道此时的dis[u]是否是最短距离。这个都没关系，我们先满足在当前dis[u]的情况下,dis[v]是否小于等于dis[u] + d[u,v]。<br>如果此时的dis[u]是最优解，dis[v]自然也是最优解。<br>如果dis[u]不是最优解，那就往前推，先保证从s到u的最短路径中，u的前一个点x是最优解。如果x不是，再往前推，早晚会推到dis[s]=0，这个妥妥地是最优解了，然后就能保证后面的都是最优解。</p>
<p>所以，我们的算法流程是这样:</p>
<ol>
<li>初始化</li>
<li>将起始点加入一个队列中</li>
<li>从队列中取出来一个点u，并将这个点从队列中移除</li>
<li>对于u所有相邻的点v，看dis[v] 是否小于等于dis[u] + d[u,v]，如果不是（说明这个点还不是最优解，所以它之前更新过的点中仍然有些不是最优解），更新dis[v]=dis[u] + d[u,v]。再看v是否在队列中，如果不是，将v加入队列。</li>
<li>回到步骤3</li>
<li>直到队列为空，算法结束，此时的dis均为最优解。</li>
</ol>
<p>算法复杂度为O(k * e)，e为边数。k为可变常数，可证明一般情况下k &lt; 2。（我不知道怎么证明的…有兴趣的可以自己查查）</p>
<p>在这个模板中，为了省内存，我的队列采用的时循环队列的形式。因为每个点最多只能同时在队列里一次，所以这个队列大小为n就足够了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SPFA &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">struct</span> Edge &#123;</span><br><span class="line">        <span class="keyword">int</span> to, next;</span><br><span class="line">        type d;</span><br><span class="line">    &#125;edge[M];</span><br><span class="line"></span><br><span class="line">    type dis[N];</span><br><span class="line">    <span class="keyword">int</span> que[N], head[N], ip;</span><br><span class="line">    <span class="keyword">bool</span> visit[N];<span class="comment">//标记各点是否在队列中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SPFA() &#123; init(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="comment">//初始化，采用链式前向星建边</span></span><br><span class="line">            <span class="built_in">memset</span>(head, -<span class="number">1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">            ip = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">            edge[ip].to=v; edge[ip].d=d; edge[ip].next=head[u]; head[u]=ip++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));<span class="comment">//清空队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=num; ++i)   dis[i] = INF;<span class="comment">//步骤1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> front = -<span class="number">1</span>, tail = -<span class="number">1</span>;</span><br><span class="line">            dis[start] = <span class="number">0</span>; visit[start] = <span class="number">1</span>; que[++tail] = start;<span class="comment">//步骤2</span></span><br><span class="line">            <span class="keyword">while</span>(front != tail) &#123;</span><br><span class="line">                <span class="keyword">if</span>(++front &gt; num)   front -= num;</span><br><span class="line">                <span class="keyword">int</span> top = que[front];<span class="comment">//步骤3</span></span><br><span class="line">                visit[top] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p=head[top]; p!=-<span class="number">1</span>; p=edge[p].next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> to = edge[p].to, temp = dis[top] + edge[p].c;</span><br><span class="line">                    <span class="keyword">if</span>(dis[to] &gt; temp) &#123;<span class="comment">//步骤4</span></span><br><span class="line">                        dis[to] = temp;</span><br><span class="line">                        <span class="keyword">if</span>(!visit[to]) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(++tail &gt; num)    tail -= num;</span><br><span class="line">                            que[tail] = to;</span><br><span class="line">                            viist[to] = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dis[end];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先，为了简化分析，我们假定图中是没有负环的。<br>如果有负环，则就没有最短路径。</p>
<blockquote>
<p>负环：一条从a到a的路径，路径上每条边的边权和为负。</p>
</blockquote>
<p>但是SPFA算法是可以判断是否有负环存在的，比较基本的做法是判断每个点进队出队的次数，这个复杂度比较高。其实有一种DFS版的SPFA，用这个来判断是否有负环的效率是非常高的，这个我们后续再讲。</p>
<p>最短路的算法中都用着一种通用的思路：</p>
<ul>
<li>初始化</li>
<li>松弛操作]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://teveillan.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网络流]]></title>
    <link href="http://teveillan.com/2015/01/04/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://teveillan.com/2015/01/04/网络流/</id>
    <published>2015-01-04T05:01:59.000Z</published>
    <updated>2015-05-06T13:24:03.000Z</updated>
    <content type="html"><![CDATA[<p>网络流，也被称为最大流。</p>
<p>模型也非常简单，就是一个管道系统，在有源点，汇点，和一堆有流速限制的管道连接的情况下，问能从源点到汇点传输流量的最大流速是多少。如下图所示。</p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/网络流.png" alt="Alt text"><br><a id="more"></a><br>假定s为源点，t为汇点，中间各箭头为管道，各管道的流速限制均为1。<br>求最大流的话，很明显，最大流为2。有两条流量：</p>
<ul>
<li>s -&gt; 1 -&gt; 3 -&gt; t，流量为1</li>
<li>s -&gt; 2 -&gt; 4 -&gt; t，流量为1</li>
</ul>
<p>现在是因为图比较简单，我们能一眼看出来。我们自然喜欢程序跑出来的结果是这样。</p>
<p>在程序过程中，自然就是找到一条流量处理一条流量。<br>如果先找到 s -&gt; 1 -&gt; 3 -&gt; t，然后找到 s -&gt; 2 -&gt; 4 -&gt; t，自然皆大欢喜。<br>但是如果程序的第一条直接找到 s -&gt; 1 -&gt; 4 -&gt; t 了呢？这样的最终结果就只有一条流量。</p>
<p>为了解决这个问题，有人提出了一种叫回退边（后悔边）的概念。<strong> 这个也是本算法的精髓所在。 </strong></p>
<blockquote>
<p>后悔边：如果我们根据原图建了一条从u到v，流量为f的边 (u,v)=f。 同时，我们也需要建一条从v到u，流量为0的边 (v,u)=0，这条边我们就称为后悔边。(u,v) 和 (v,u)互为反向边。 </p>
</blockquote>
<p>同时，在程序进行过程中，如果我们如果从残余网络中找到一条从s到v的流量为f，在更新的过程中，我们首先要把最终答案加上c，然后我们不仅要把在该流量上的各边的剩余流量减去f，同时还要把流量上各条边的反向边的流量加上f。</p>
<p>这样做有什么好处呢?</p>
<p>还是以上图为例，如果我们先找到了 s -&gt; 1 -&gt; 3 -&gt; t，流量为1。我们首先在最终答案中加1，然后在更新的过程中不仅要把 (s,1)、(1,4)、(4,t) 这几条边的剩余流量减1， 还要把 (1,s)、(4,1)、(t,4) 的剩余流量加1。 </p>
<p>此时的残余网络为：</p>
<ul>
<li>(s,1) = 0, (1,s) = 1</li>
<li>(s,2) = 1, (2,s) = 0</li>
<li>(1,3) = 1, (3,1) = 0</li>
<li>(1,4) = 0, (4,1) = 1</li>
<li>(2,4) = 1, (4,2) = 0</li>
<li>(3,t ) = 1, (t,3 ) = 0</li>
<li>(4,t ) = 0, (t,4 ) = 1</li>
</ul>
<p>然后我们从残余网络中找流量，<strong>发现此时能找到一条 s -&gt; 2 -&gt; 4 -&gt; 1 -&gt; 3 -&gt; t 的流量了！</strong>然后我们还按之前的方式更新。再找的时候找不到新的流量了，算法结束。此时的结果是和我们之前用肉眼观察的结果是一样的。</p>
<p>这就是后悔边的神奇之处。</p>
<p><strong>后悔边，顾名思义，就是给了一条边后悔的权利。在算法过程中，原图的边和后悔边是没有区别的，所以找流量的时候也没有任何区别。</strong></p>
<p>这条边存在的意义是，还拿刚刚那条 s -&gt; 2 -&gt; 4 -&gt; 1 -&gt; 3这条流量来说。里面存在一条后悔边(4,1)，它的意义是：</p>
<ul>
<li><strong> 之前已经更新过的流量中，有一条从4到t的流量<code>4 -&gt; t</code>，这条流量我可以用到。</strong></li>
<li><strong> 目前的残余网络中，还存在一条从1到s得流量<code>1 -&gt; 3 -&gt; t</code>，这条流量可以替换你之前更新过的流量 <code>1 -&gt; 4 -&gt; t</code>。</strong></li>
<li><strong> 为什么不能你用<code>1 -&gt; 3 -&gt; t</code>，我用<code>4 -&gt; t</code>呢。这样的得到的总流量多一些，我们来交换吧。</strong></li>
<li><strong> 你把你的流量退回去，用我给你的。我用你之前的。 至于中间的(4,1)，退回去我也用不上，大不了都不用了吧。</strong></li>
</ul>
<p>这样下来，最佳方案就出现了。</p>
<p>可以发现，在有后悔边存在的情况下，先找哪条流量后找哪条流量就已经不重要了。反正都是可以做修改的。这样的话，只要考虑如何高效地找流量就好了。这个当然不能随便找，有环的话肯定要进入死循环。</p>
<p>在<strong>Dinic</strong>算法中，我们采用了分层图的形式。分层用BFS来实现。</p>
<ul>
<li>首先，将源点的level设为0，并将源点加入队列。</li>
<li>从队列中取出一个点u，遍历以它为起点还有流量的边，找到点v。如果点v还没被加入队列过，将v的level设为level[u]+1，并将v加入队列。</li>
<li>回到步骤2，直到队列为空。</li>
</ul>
<p>然后我们规定，level为<code>a</code>的点只能向level为<code>a+1</code>的点找流量,这样就能很有效地避免环的出现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e7</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">struct</span> Edge&#123;</span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="keyword">int</span> head[N], level[N], que[N], ip;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, -<span class="number">1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    ip = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">makelevel</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">//将图分层</span></span><br><span class="line">    <span class="built_in">memset</span>(level,<span class="number">0</span>,<span class="keyword">sizeof</span>(level));</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    que[num++]=s;</span><br><span class="line">    level[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> top=que[i];</span><br><span class="line">        <span class="keyword">if</span>(top==t)  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//找到t了，后面再找level肯定比t大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=head[top];k!=-<span class="number">1</span>;k=edge[k].next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!level[edge[k].to]&amp;&amp;edge[k].c&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                que[num++]=edge[k].to;</span><br><span class="line">                level[edge[k].to]=level[top]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> maxf,<span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">//从残余网络中找流量</span></span><br><span class="line">    <span class="keyword">if</span>(now==t)  <span class="keyword">return</span> maxf;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=head[now];k!=-<span class="number">1</span>;k=edge[k].next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[k].c&gt;<span class="number">0</span>&amp;&amp;level[edge[k].to]==(level[now]+<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> c=dfs(edge[k].to,min(maxf-ret,edge[k].c),t);</span><br><span class="line">            edge[k].c-=c;</span><br><span class="line">            edge[k^<span class="number">1</span>].c+=c;</span><br><span class="line">            ret+=c;</span><br><span class="line">            <span class="keyword">if</span>(ret==maxf)   <span class="keyword">return</span>  ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    --level[now]; <span class="comment">//一个优化，说明往level[now]+1找流量已经找不到了。自己就降一个level。</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(makelevel(s,t))   ans+=dfs(s,INF,t);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c,<span class="keyword">int</span> f)</span> </span>&#123;<span class="comment">//有向边f为0 ,否则为 c</span></span><br><span class="line">    edge[ip].to=v;edge[ip].c=c;edge[ip].next=head[u];head[u]=ip++;</span><br><span class="line">    edge[ip].to=u;edge[ip].c=f;edge[ip].next=head[v];head[v]=ip++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>网络流，也被称为最大流。</p>
<p>模型也非常简单，就是一个管道系统，在有源点，汇点，和一堆有流速限制的管道连接的情况下，问能从源点到汇点传输流量的最大流速是多少。如下图所示。</p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/网络流.png" alt="Alt text"><br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://teveillan.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[New Year]]></title>
    <link href="http://teveillan.com/2015/01/02/New-Year/"/>
    <id>http://teveillan.com/2015/01/02/New-Year/</id>
    <published>2015-01-02T15:16:29.000Z</published>
    <updated>2015-05-06T13:24:03.000Z</updated>
    <content type="html"><![CDATA[<p>新的一年，要把CF刷红，TC刷红。<br>托福要过，N2看着办吧。。。<br>至于签了百度什么的。。。呵呵呵呵。。。妥妥地不想回去了。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[What’t this?]]>
    
    </summary>
    
      <category term="随笔" scheme="http://teveillan.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>